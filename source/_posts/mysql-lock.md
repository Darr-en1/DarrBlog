---
title: mysql-lock
copyright: true
permalink: 1
top: 0
date: 2020-11-08 16:39:54
tags:
    - mysql
    - lock
categories: mysql
password:
---


MySQL通过锁控制资源的访问规则，保证数据的正确性。
而根据加锁的范围，可被分为全局锁、表级锁和行锁。他们都有什么作用呢？有让我们一探究竟吧！<!--more-->

## 全局锁

### FTWRL

全局锁将对整个数据库实例加锁，使得整个库处于只读状态，会阻塞DDL和部分DML(select不被阻塞)语句。
通过输入命令 Flush tables with read lock (FTWRL)让整个库处于只读状态。

全局锁的典型使用场景是做全库逻辑备份。
但是在备份过程中整个库完全处于只读状态，因此会出现一些隐患：
- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
- 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。

如此大的隐患势必在大部分业务场景下是不能接受，那有没有更好的办法呢？
### single-transaction 实现数据库备份
我们可以通过一致性视图实现。当我们使用InnoDB时，倘若我们将事务隔离级别设置成一致性读。
基于MVCC原理，当我们开启一个事务，我们会获取到一份和数据库一样的完整数据，并和其他事务相互隔离。
相当于对数据库进行了一次快照。因此我们便可以对当前数据进行备份，并不影响其他事务操作。

mysql官方自带的逻辑备份工具 mysqldump。
当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。
但这又存在一个问题。它需要数据库存储引擎处于一致性读的事务隔离级别。倘若使用MYISAM，则不能使用该功能。

### readonly 和 FTWRL
mysql可以设置`set global readonly=true`将数据库变成全库只读。但他两的适用范围却不一样：
- 在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大。
- 在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。
而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。

## 表级锁
MySQL里面表级别的锁有两种：表锁和元数据锁（meta data lock，MDL)。

### 表锁

MyISAM存储引擎只支持表锁。

表锁的语法是 lock tables … read/write。通过 unlock tables主动释放锁，也可以在客户端断开的时候自动释放。

当一个线程获取到表级写锁后，只能由该线程对表进行读写操作，别的线程必须等待该线程释放锁以后才能操作

当一个线程获取到表级读锁后，该线程只能读取数据不能修改数据，其它线程也只能加读锁，不能加写锁

### MDL
MDL在MySQL 5.5版本中引入。MDL不需要显式使用，在访问一个表的时候会被自动加上。

**当对一个表做增删改查操作的时候，加MDL读锁**；

**当要对表做结构变更操作的时候，加MDL写锁**。


读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。

读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到MDL锁后，直到事务执行完才会将锁释放。

**如果A会话开启一个事务对t表进行了一次查询并没有提交，该操作会获取MDL读锁。然后B会话对t表字段进行更改，上一个事务没有提交MDL读锁没有被释放，因此B会话block。
但是之后所有要在表t上新申请MDL读锁的请求也会被B会话阻塞。**

#### 如何安全地给小表加字段？

首先我们要解决长事务，事务不提交，就会一直占着MDL锁。
在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。
如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。
倘若要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，这时候kill可能未必管用，因为新的请求马上就来了。
比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。
之后开发人员或者DBA再通过重试命令重复这个过程。

#### Online DDL
mysql 5.6以前 在DDL执行期间其他DML不能并行，运维人员对表的结构更改会导致该表的业务停滞。
这在很多时候是不能容忍的，因此在mysql5.6 引入了Online DDL ,它使得在DDL执行期间其他DML可以并行。

Online DDL下，当获取到MDL写锁会将其降级成MDL读锁，然后真正做DDL操作。因此在DDL操作的过程中，表处于读锁状态。
DML不被阻塞。DDL操作完成后会升级成MDL写锁然后释放MDL锁。

### 行锁
行锁是粒度最小的锁。



